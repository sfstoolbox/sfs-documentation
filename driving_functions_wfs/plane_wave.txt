.. _sec-driving-functions-wfs-plane-wave:

Plane Wave
~~~~~~~~~~

.. plot::
    :context: close-figs

    nk = 0, -1, 0  # direction of plane wave
    omega = 2 * np.pi * 1000  # frequency
    xref = 0, 0, 0  # 2.5D reference point
    x0, n0, a0 = sfs.array.circular(200, 1.5)
    grid = sfs.util.xyz_grid([-1.75, 1.75], [-1.75, 1.75], 0, spacing=0.02)
    d = sfs.mono.drivingfunction.wfs_25d_plane(omega, x0, n0, nk, xref)
    a = sfs.mono.drivingfunction.source_selection_plane(n0, nk)
    twin = sfs.tapering.tukey(a,.3)
    p = sfs.mono.synthesized.generic(omega, x0, n0, d * twin * a0 , grid,
        source=sfs.mono.source.point)
    normalization = 0.5
    sfs.plot.soundfield(normalization * p, grid);
    sfs.plot.secondarysource_2d(x0, n0, grid)

.. _fig-wfs-25d-plane-wave:

.. figure:: ../img/placeholder.png
    :align: center

    Sound pressure for a monochromatic plane wave synthesized with 2.5D
    |WFS| :eq:`D.wfs.ps.2.5D`.  Parameters: :math:`\n_k = (0, -1, 0)`,
    :math:`\xref = (0, 0, 0)`, :math:`f = 1` kHz.

By inserting the source model of a plane wave :eq:`S.pw` into :eq:`D_wfs`
and :eq:`D25D_wfs` it follows

.. math::
    :label: D.wfs.pw

    D(\x_0,\w) = 2 w(\x_0) A(\w)
        \i\wc  \scalarprod{\n_k}{\n_{\x_0}}
        \e{-\i\wc  \scalarprod{\n_k}{\x_0}},

.. math::
    :label: D.wfs.pw.2.5D

    D_\text{2.5D}(\x_0,\w) = 2 w(\x_0) A(\w)
        \sqrt{2\pi|\xref-x_0|}
        \sqrt{\i\wc } \scalarprod{\n_k}{\n_{\x_0}}
        \e{-\i\wc  \scalarprod{\n_k}{\x_0}}.

Transferred to the temporal domain via an inverse Fourier transform :eq:`ifft`,
it follows

.. math::
    :label: d.wfs.pw

    d(\x_0,t) = 2 a(t) * h(t) * w(\x_0) \scalarprod{\n_k}{\n_{\x_0}}
        \dirac{t - \frac{\scalarprod{\n_k}{\x_0}}{c}},

.. math::
    :label: d.wfs.pw.2.5D

    d_\text{2.5D}(\x_0,t) = 2 a(t) * h_\text{2.5D}(t) * w(\x_0)
        \sqrt{2\pi|\xref-x_0|} \scalarprod{\n_k}{\n_{\x_0}}
        \dirac{t - \frac{\scalarprod{\n_k}{\x_0}}{c}},

where

.. math::
    :label: h.wfs

    h(t) = \mathcal{F}^{-1}\left\{\i\wc \right\},

and

.. math::
    :label: h.wfs.2.5D

    h_\text{2.5D}(t) = \mathcal{F}^{-1}\left\{
        \sqrt{\i\wc }\right\}

denote the so called pre-equalization filters in |WFS|.

The window function :math:`w(\x_0)` for a plane wave as source model can be
calculated after [Spors2008]_

.. math::
    :label: wfs.pw.selection

    w(\x_0) = 
        \begin{cases}
            1 & \scalarprod{\n_k}{\n_{\x_0}} > 0 \\
            0 & \text{else}
        \end{cases}


.. vim: filetype=rst spell:
